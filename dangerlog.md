# Danger log
1.	When using std::thread to create a new thread, we forget that this thread object is created on the stack, and it will be automatically destructed when it runs out of scope. So we solved it by using thread::detach() on that thread, or call thread::join() to wait until the thread finishes before it is destructed. 
2.	We didn’t initialize the pointer, assuming it will be initialized to be null by the default constructor. This is wrong because pointer will not be null if we don’t initialize it. And this causes some segmentation fault later on.
3.	At first we used a set to record the sequence number that is sent by world or amazon, later we realized that if our server runs for a long time, these numbers will not be deleted and the memory might be insufficient. We make our server robust by create a new data structure, which combines a set and a priority queue. We pop the smallest number in the set and the priority when the numbers exceeds our pre-defined capacity.
4.	We made a mistake by using a lock that is defined in the object to set up database connection. We want to lock some sql to make those operations atomic. However, we create a new object every time we want to access database, and it creates a new lock every time, which means those sql operations will not be locked. We solved this by using a locked that is shared by every such object.
5.	When we want to insert some messages into a google protocol buffer, it internally allocates some memory on heap(which might fail). We achieved higher exception safety level by using unique pointer on the google protocol buffer pointer. So the previous allocated memory will be deallocated when exception happens.
6. When we are combining the codes, and use the interface, there is a mistake in passing parameters, the order wanted is different with the order passing in. In addition, we need more clear documentation and more careful when using functions.
7. There are some misuse of the name set up in the database, which will be write in the string, and there is no warning on the variable name, so we need to have an uniform naming rule and keep the consitent to avoid mistyping something in the strings. 
8. When we want to reply to the amazon when we send out the delivery commands to the world, we chose to send while we receiving the acks. However, the world may finish delivery very fast, so that the receiving of the ack may happen at the same time as receiving completions, which may cause race condition for sending out our two GPB protocol, resulting in missing update destination, and package status. 